c
 c
c
dc
cell.moves([row_idx,col_idx])
cell.moves[row_idx,col_idx]
cell.moves
cell.valid_moves(self, [row_idx,col_idx], player, opponent)
col_idx
row_idx
c
row_idx
c
row_idx
row_id
c
row_idx
c
row_idx
col_idx
c
row_idx
col_idx
c
col_idx
row_idx
c
row_idx
c
col_idx
c
col_idx
cell.valid_moves(self, [row_idx,col_idx], player, opponent)
c
cell.valid_moves(self, [row_idx,col_idx], player, opponent)
col_idx
row_idx
c
 c
c
exit
n
row_idx
c
exit
player
in_check?
exit
@board.in_check?(@current_player,other_player)
@board.in_check?(other_player,@current_player)
c
exitc
exit
c
exit
@grid[1][3].classexit
@grid[1][3].class
@grid[3][3].class
@gird[3][3]
@grid[1][3].class
@grid[1][3]
cell.diagonal_moves([row_idx,col_idx],-1,1,)
cell.diagonal_moves([row_idx,col_idx],1,1,)
col_idx
row_idx
c
cc
c
finish
f
finish
break
c
finish
next
done
end
finish
c
cc
c
cc
c
cc
c
exit
cell.diagonal_moves([row_idx,col_idx],1,1)
cell.class
@grid[4][0].class
@grid[3][1].class
@grid[2][2].class
@board.grid[2][2]
cell.moves([row_idx,col_idx])
cell.moves([col_idx,row_idx])
cell.moves([row_idx,col_idx])
cell.class
cell.color
cell.moves([row_idx,col_idx]).include?(king_pos)
king_pos
cell.moves([row_idx,col_idx])
king_pos
col_idx
row_idx
c
n
c
cc
c
cc
c
cc
c
cccc
c
row_idx
col_idx
cell.moves
c
exit
exti
player.color
king_pos
cell.moves([row_idx,col_idx])
cell.color
c
player.color
current_pos
board
c
@board.grid[4][0].class
@board.grid[0][4].class
@board[0][4]
current_pos
s
cell.class
king_pos
cell.all_moves("asdf",[row_idx,col_idx],opponent,player)
s
cell.color != player.color && cell.color != 'unique'
cell.class
s
cell.class
s
col_idx
s
row_idx
s
row_idx
s
row_idx
s
col_idx
row_idx
s
@grid[0].length
@grid.length
s
c
back
b
n
col_idx
row_idx
n
cell.color
cell.class
n
opponent.color
player.color
cell.color
cell.class
s
new_pos
c
new_pos
c
hostile_moves.include?(king_pos)
king_pos
hostile_moves
@grid
n
col_idx
row_idx
@grid[3][2].class
n
opponent.color
player.color
s
dup_board.in_check?(player,opponent)
current_pos
new_pos
c
new_pos
current_pos
dup_board.in_check?(player,opponent)
c
dup_board.in_check?(player,opponent)
new_pos
current_pos
c
n
dup_board.grid[new_pos[0]][new_pos[1]].class
dup_board.grid[current_pos[0]][current_pos[1]].class
dup_board.grid[new_pos[0]][new_pos[1]].class
dup_board.grid[new_pos[0]][new_pos[1]]
dup_board.grid[0][0].class
dup_board[0][0].class
c
cc
c
cc
c
 c
c
cc
c
ccc
c
dup_board.grid[1][3].class
dup_board.grid[1][3]
dup_board.grid[0][3]
dup_board[0][3]
dup_board
board
Display.render()
Display.render
Display
Display.render
dup_board.render
dup_board.in_check?(player,opponent)
dup_board.in_check?(player,oponent)
current_pos
new_pos
c
new_pos
c
new_pos
c
new_pos
c
new_pos
c
new_pos
current_pos
c
new_pos
current_pos
c
exitc
exit
c
n
c
exit
c
pos
